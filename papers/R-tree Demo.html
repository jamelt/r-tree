
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>R-tree Demo</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (X11; I; SunOS 5.5 sun4m) [Netscape]">
</HEAD>
<BODY BGCOLOR="#C0C0C0">

<H1 ALIGN=CENTER>R-tree Demo</H1>

<P>
<HR></P>

<p> The R-tree <a
href="http://www.cs.umd.edu/~brabec/quadtree/docs/references.html#gutt84">[Gutt84]</a>
is an object hierarchy which is applicable to arbitrary spatial objects
which is formed by aggregating their minimum bounding boxes and storing the
aggregates in a tree structure.  The aggregation is based, in part, on
proximity of the objects or bounding boxes.  The number of objects or
bounding boxes that are aggregated in each node is permitted to range
between <i>m <= ceil(M /2)</i> and <i> M </i>, thereby leading us to use the
prefix <i> (m,M) </i> to characterize a particular R-tree and mirroring the
effect of a B-tree.  The root node in an R-tree has at least two entries
unless it is a leaf node in which case it has just one entry corresponding
to the bounding box of an object. </p>

<P>The R-tree can be constructed in either a dynamic or a static manner.
The dynamic methods build the R-tree as the objects are encountered
while the static methods wait until all the objects have been input
before building the tree.  The results of the static methods are
usually characterized as being <i> packed </i> since knowing all of the
data in advance permits each R-tree node to be filled to its capacity.

<P>There are two principal methods of determining how to fill each R-tree
node.  The most natural method is to take the space occupied by the
objects into account when deciding which ones to aggregate.  An
alternative is to order the objects prior to performing the
aggregation.  However, in this case, once an order has been
established, there isn't really a choice as to which objects (or
bounding boxes) are being aggregated.  The most obvious order,
although not particularly interesting or useful, is one that preserves
the order in which the objects were initially encountered  (i.e.,
objects in aggregate <i> i </i> have been encountered before those in
aggregate <i> i+1 </i>).  We do not use this technique in our applet.

<P>In this applet, all objects are assumed to be lines.  There
are many R-tree variants.  They differ on whether the structure is
built in a static or dynamic manner.  In all cases, in our applet, the
R-tree is built as the data is encountered.  The difference between
the static and dynamic methods is that the static methods rebuild the
entire R-tree as each new object is added.  In contrast, the dynamic
methods add the new objects to the existing R-tree.

<P>The dynamic methods differ in the techniques used to split an
overflowing node during insertion.  There are two types of dynamic
methods.  The first type has the goal of minimizing coverage and
overlap. These goals are at times contradictory and thus heuristics
are often used.   The second type makes use of the ordering applied to
the objects (actually their bounding boxes) using their centroids in
our examples.  They are termed <i> nonpacked </i>.  In this case, the
result is equivalent to a B+-tree and all update algorithms are
B+-tree algorithms.  These update algorithms do not make use of the
spatial extent of the bounding boxes to determine how to split a node.
Thus the goals of minimizing overlap or coverage are not part of the
node splitting process although this does not preclude these methods
from having good behavior with respect to these goals.

<P>Users have the option of trying a number of different
<a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html"> node splitting algorithms</a> that 
include:

<ol>
<li>Dynamic methods based on minimizing coverage and/or overlap</li>
<ol type="l">
<li> <a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#exhaust">Exhaustive search</a>
<li> <a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#quad">Quadratic method</a>
<li> <a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#linear">Linear method</a>
<li> <a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#rstar">R*-tree</a>
<li> <a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#ang">Ang/Tan method</a>
</ol>

<li>Dynamic methods based on an ordering (nonpacked)</li>
<ol>
<li><a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#hilnon">Hilbert nonpacked</a></li>
<li><a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#mornon">Morton nonpacked</a></li>
</ol>

<li>Static methods based on an ordering</li>
<ol>
<li><a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#packed">Packed</a></li>
<li><a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#hilpack">Hilbert packed</a></li>
<li><a href="http://www.cs.umd.edu/~brabec/quadtree/docs/rtree_split_rules.html#morpack">Morton packed</a></li>
</ol>
</ol>


The static methods differ on the basis of the method used to order the
objects.  The dynamic methods that are not based on an ordering (i.e.,
reduction of coverage and overlap) range from being quite simple
(e.g.,exhaustive search) to being fairly complicated (e.g., R*-tree <a
href="http://www.cs.umd.edu/~brabec/quadtree/docs/references.html#beck90c">[Beck90c]</a>). Some
just split the overflowing node, while others (i.e., the R*-tree) try to
reinsert some of the objects and nodes from the overflowing nodes thereby
striving for better overall behavior (e.g., reduction in coverage and
overlap).  For more details on the general topic of R-trees, see pages
270-303 and 790-794 of <A HREF="http://www.cs.umd.edu/~hjs/multidimensional-book-flyer.pdf">Samet,
<I>Foundations of Multidimensional and Metric Data Structures</I></A>



<H4>Instructions</H4>

<P>In <B><font color="red">Insert</font></B> mode, click the mouse to
specify a new point.</p>

<p>In <B><font color="red">Delete</font></B> mode, delete the point nearest
to the mouse at position <i>p</i>.  The deletion occurs when the mouse is
clicked.  As the mouse is moved, the point that will be deleted is shown in
orange.  </p>

<p>In <B><font color="red">Window</font></B> mode, click and drag the mouse
to specify a query rectangle.  The points that have been retrieved are shown
in blue.

<p>In <B><font color="red">Nearest</font></B> mode, click to specify the query point <i>p</i>.
All points are returned in the order of the distance from <i> p
</i>.</p>

<P><APPLET code="vasco.points.main" archive="points.jar"
        width=740 height=750>
<param name="treetype" value="R-Tree">
</APPLET></P>

</BODY>
</HTML>





